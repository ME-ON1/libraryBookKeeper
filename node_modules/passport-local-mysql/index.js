const crypto = require('crypto');
const LocalStrategy = require('passport-local').Strategy;

const pbkdf2 = require('./lib/pbkdf2');
const errors = require('./lib/errors');

const globalOptions = {};

module.exports = class AuthManager {
  constructor(connection, table, options) {
    options = options || {};
    globalOptions.saltlen = options.saltlen || 32;
    globalOptions.iterations = options.iterations || 25000;
    globalOptions.keylen = options.keylen || 512;
    globalOptions.encoding = options.encoding || 'hex';
    globalOptions.digestAlgorithm = options.digestAlgorithm || 'sha256'; // To get a list of supported hashes use crypto.getHashes()
    globalOptions.table = table;
    globalOptions.connection = connection;

    // Populate field names with defaults if not set
    globalOptions.usernameField = options.usernameField || 'username';

    // option to find username case insensitively
    globalOptions.hashField = options.hashField || 'hash';
    globalOptions.saltField = options.saltField || 'salt';

    // if (options.limitAttempts) {
    //   options.lastLoginField = options.lastLoginField || 'last';
    //   options.attemptsField = options.attemptsField || 'attempts';
    //   options.interval = options.interval || 100; // 100 ms
    //   options.maxInterval = options.maxInterval || 300000; // 5 min
    //   options.maxAttempts = options.maxAttempts || Infinity;
    // }

    options.errorMessages = options.errorMessages || {};
    globalOptions.errorMessages = {};
    globalOptions.errorMessages.MissingPasswordError = options.errorMessages.MissingPasswordError || 'No password was given';
    globalOptions.errorMessages.AttemptTooSoonError = options.errorMessages.AttemptTooSoonError || 'Account is currently locked. Try again later';
    globalOptions.errorMessages.TooManyAttemptsError = options.errorMessages.TooManyAttemptsError || 'Account locked due to too many failed login attempts';
    globalOptions.errorMessages.NoSaltValueStoredError = options.errorMessages.NoSaltValueStoredError || 'Authentication not possible. No salt value stored';
    globalOptions.errorMessages.IncorrectPasswordError = options.errorMessages.IncorrectPasswordError || 'Password or username is incorrect';
    globalOptions.errorMessages.IncorrectUsernameError = options.errorMessages.IncorrectUsernameError || 'Password or username is incorrect';
    globalOptions.errorMessages.MissingUsernameError = options.errorMessages.MissingUsernameError || 'No username was given';
    globalOptions.errorMessages.UserExistsError = options.errorMessages.UserExistsError || 'A user with the given username is already registered';
    globalOptions.errorMessages.FieldsNotFound = options.errorMessages.FieldsNotFound || 'Required fields not found in table';
  }

  setPassword(username, password, cb) {
    const promise = Promise.resolve()
      .then(() => {
        if (!password) {
          throw new errors.MissingPasswordError(globalOptions.errorMessages.MissingPasswordError);
        }
      })
      .then(() => randomBytes(globalOptions.saltlen))
      .then(saltBuffer => saltBuffer.toString(globalOptions.encoding))
      .then(salt => {
        globalOptions.connection.query('UPDATE `' + globalOptions.table + '` SET `' + globalOptions.saltField + '` = ? LIMIT 1', [salt]);
        return salt;
      })
      .then(salt => pbkdf2Promisified(password, salt, globalOptions))
      .then(hashRaw => {
        globalOptions.connection.query('UPDATE `' + globalOptions.table + '` SET `' + globalOptions.saltField + '` = ? LIMIT 1', [new Buffer(hashRaw, 'binary').toString(globalOptions.encoding)]);
      })
      .then(() => this);

    if (!cb) {
      return promise;
    }

    promise
      .then(result => cb(null, result))
      .catch(err => cb(err));
  };

  changePassword(username, oldPassword, newPassword, cb) {
    const promise = Promise.resolve()
      .then(() => {
        if (!oldPassword || !newPassword) {
          throw new errors.MissingPasswordError(globalOptions.errorMessages.MissingPasswordError);
        }
      })
      .then(() => this.authenticate(username, oldPassword))
      .then(({ user }) => {
        if (!user) {
          throw new errors.IncorrectPasswordError(globalOptions.errorMessages.IncorrectPasswordError);
        }
      })
      .then(() => this.setPassword(username, newPassword))
      .then(() => this);

    if (!cb) {
      return promise;
    }

    promise
      .then(result => cb(null, result))
      .catch(err => cb(err));
  };

  authenticate(username, password, cb) {
    const promise = Promise.resolve()
      .then(() => globalOptions.connection.query('SELECT `' + globalOptions.saltField + '` FROM `' + globalOptions.table + '` WHERE `' + globalOptions.usernameField + '` = ? LIMIT 1', [username]))
      .then(salt => pbkdf2Promisified(password, salt, globalOptions))
      .then(hash => globalOptions.connection.query('SELECT * FROM `' + globalOptions.table + '` WHERE `' + globalOptions.usernameField + '` = ? AND `' + globalOptions.hashField + '` = ? LIMIT 1', [username, hash]))
      .then(values => {
        if(values.length > 0) {
          return { user: values[0], error: null };
        }
        else {
          return { user: false, error: new errors.IncorrectUsernameError(globalOptions.errorMessages.IncorrectUsernameError) };
        }
      });
    if (!cb) {
      return promise;
    }

    promise
      .then(({ user, error }) => cb(null, user, error))
      .catch(err => cb(err));
  };

  // Passport Interface
  serializeUser() {
    return function(user, cb) {
      cb(null, user.get(globalOptions.usernameField));
    };
  };

  deserializeUser() {
    return (username, cb) => {
      this.findByUsername(username, cb);
    };
  };

  register(user, password, cb) {
    const promise = Promise.resolve()
      .then(() => {
        if (!user.get(globalOptions.usernameField)) {
          throw new errors.MissingUsernameError(globalOptions.errorMessages.MissingUsernameError);
        }
      })
      .then(() => this.findByUsername(user.get(globalOptions.usernameField)))
      .then((existingUser) => {
        if (existingUser) {
          throw new errors.UserExistsError(globalOptions.errorMessages.UserExistsError);
        }
      })
      .then(() => user.setPassword(password))
      .then(() => user.save());

    if (!cb) {
      return promise;
    }

    promise
      .then(result => cb(null, result))
      .catch(err => cb(err));
  };

  strategyCallback() {
    return this.authenticate;
  }

  createStrategy() {
    return new LocalStrategy(globalOptions, this.strategyCallback());
  };
};

function pbkdf2Promisified(password, salt, options) {
  return new Promise((resolve, reject) => pbkdf2(password, salt, options, (err, hashRaw) => err ? reject(err) : resolve(hashRaw)));
}

function randomBytes(saltlen) {
  return new Promise((resolve, reject) => crypto.randomBytes(saltlen, (err, saltBuffer) => err ? reject(err) : resolve(saltBuffer)));
}

module.exports.errors = errors;
